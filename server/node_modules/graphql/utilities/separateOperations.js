<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.separateOperations = separateOperations;

var _kinds = require("../language/kinds.js");

var _visitor = require("../language/visitor.js");
========
// @flow strict
import type { ObjMap } from '../jsutils/ObjMap';

import type {
  DocumentNode,
  OperationDefinitionNode,
  SelectionSetNode,
} from '../language/ast';
import { Kind } from '../language/kinds';
import { visit } from '../language/visitor';
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow

/**
 * separateOperations accepts a single AST document which may contain many
 * operations and fragments and returns a collection of AST documents each of
 * which contains a single operation as well the fragment definitions it
 * refers to.
 */
<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js
function separateOperations(documentAST) {
  var operations = [];
  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.

  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var definitionNode = _documentAST$definiti2[_i2];

========
export function separateOperations(
  documentAST: DocumentNode,
): ObjMap<DocumentNode> {
  const operations: Array<OperationDefinitionNode> = [];
  const depGraph: DepGraph = Object.create(null);

  // Populate metadata and build a dependency graph.
  for (const definitionNode of documentAST.definitions) {
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js

      case _kinds.Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
========
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet,
        );
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow
        break;
    }
  }

  // For each operation, produce a new synthesized AST which includes only what
  // is necessary for completing that operation.
<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js


  var separatedDocumentASTs = Object.create(null);
========
  const separatedDocumentASTs = Object.create(null);
  for (const operation of operations) {
    const dependencies = new Set();
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow

  var _loop = function _loop(_i4) {
    var operation = operations[_i4];
    var dependencies = new Set();

    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {
      var fragmentName = _collectDependencies2[_i6];
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }

<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js

    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted
========
    // Provides the empty string for anonymous operations.
    const operationName = operation.name ? operation.name.value : '';

    // The list of definition nodes to be included for this operation, sorted
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow
    // to retain the same order as the original document.
    separatedDocumentASTs[operationName] = {
<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js
      kind: _kinds.Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(function (node) {
        return node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);
      })
========
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) =>
          node === operation ||
          (node.kind === Kind.FRAGMENT_DEFINITION &&
            dependencies.has(node.name.value)),
      ),
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow
    };
  };

  for (var _i4 = 0; _i4 < operations.length; _i4++) {
    _loop(_i4);
  }

  return separatedDocumentASTs;
}

type DepGraph = ObjMap<Array<string>>;

// From a dependency graph, collects a list of transitive dependencies by
// recursing through a dependency graph.
function collectTransitiveDependencies(
  collected: Set<string>,
  depGraph: DepGraph,
  fromName: string,
): void {
  if (!collected.has(fromName)) {
    collected.add(fromName);
<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js
    var immediateDeps = depGraph[fromName];
========
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow

    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== undefined) {
      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {
        var toName = immediateDeps[_i8];
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}

<<<<<<<< HEAD:server/node_modules/graphql/utilities/separateOperations.js
function collectDependencies(selectionSet) {
  var dependencies = [];
  (0, _visitor.visit)(selectionSet, {
    FragmentSpread: function FragmentSpread(node) {
========
function collectDependencies(selectionSet: SelectionSetNode): Array<string> {
  const dependencies = [];

  visit(selectionSet, {
    FragmentSpread(node) {
>>>>>>>> develop:server/node_modules/graphql/utilities/separateOperations.js.flow
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
